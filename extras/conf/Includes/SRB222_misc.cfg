linedefflags
{
	1 = "[0] Impassable";
	2 = "[1] Block Enemies";
	4 = "[2] Double-Sided";
	8 = "[3] Upper Unpegged";
	16 = "[4] Lower Unpegged";
	32 = "[5] Slope Skew (E1)";
	64 = "[6] Not Climbable";
	128 = "[7] No Midtexture Skew (E2)";
	256 = "[8] Peg Midtexture (E3)";
	512 = "[9] Solid Midtexture (E4)";
	1024 = "[10] Repeat Midtexture (E5)";
	2048 = "[11] Netgame Only";
	4096 = "[12] No Netgame";
	8192 = "[13] Effect 6";
	16384 = "[14] Bouncy Wall";
	32768 = "[15] Transfer Line";
}


// LINEDEF ACTIVATIONS
// Make sure these are in order from lowest value to highest value
linedefactivations
{
}


// Linedef flags UDMF translation table
// This is needed for copy/paste and prefabs to work properly
// When the UDMF field name is prefixed with ! it is inverted
linedefflagstranslation
{
	1 = "blocking";
	2 = "blockmonsters";
	4 = "twosided";
	8 = "dontpegtop";
	16 = "dontpegbottom";
	32 = "skewtd";
	64 = "noclimb";
	128 = "noskew";
	256 = "midpeg";
	512 = "midsolid";
	1024 = "wrapmidtex";
	2048 = "nosonic";
	4096 = "notails";
	8192 = "noknux";
	16384 = "bouncy";
	32768 = "transfer";
}


linedefflags_udmf
{
	blocking = "[0] Impassable";
	blockmonsters = "[1] Block Enemies";
	twosided = "[2] Double-Sided";
	dontpegtop = "[3] Upper Unpegged";
	dontpegbottom = "[4] Lower Unpegged";
	skewtd = "[5] Slope Skew (E1)";
	noclimb = "[6] Not Climbable";
	noskew = "[7] No Midtexture Skew (E2)";
	midpeg = "[8] Peg Midtexture (E3)";
	midsolid = "[9] Solid Midtexture (E4)";
	wrapmidtex = "[10] Repeat Midtexture (E5)";
	nosonic = "[11] No Sonic";
	notails = "[12] No Tails";
	noknuckles = "[13] No Knuckles";
	bouncy = "[14] Bouncy Wall";
	transfer = "[15] Transfer Line";
	fogwall = "[16] Fog Wall";
	horizoneffect = "[17] Horizon Effect";
	notriggerorder = "[18] Trigger Out of Order";
}


linedefactivations_udmf
{
}

thingflags
{
	1 = "[1] Extra";
	2 = "[2] Flip";
	4 = "[4] Special";
	8 = "[8] Ambush";
}

thingflags_udmf
{
}


// Thing flags UDMF translation table
// This is needed for copy/paste and prefabs to work properly
// When the UDMF field name is prefixed with ! it is inverted
thingflagstranslation
{
	1 = "skill1";
	2 = "skill2";
	4 = "skill3";
	8 = "ambush";
}


// DEFAULT SECTOR BRIGHTNESS LEVELS
sectorbrightness
{
	255;
	248;
	240;
	232;
	224;
	216;
	208;
	200;
	192;
	184;
	176;
	168;
	160;
	152;
	144;
	136;
	128;
	120;
	112;
	104;
	96;
	88;
	80;
	72;
	64;
	56;
	48;
	40;
	32;
	24;
	16;
	8;
	0;
}

/*
TEXTURES AND FLAT SOURCES
This tells Doom Builder where to find the information for textures
and flats in the IWAD file, Addition WAD file and Map WAD file.

Start and end lumps must be given in a structure (of which the
key name doesnt matter) and any textures or flats in between them
are loaded in either the textures category or flats category.

For textures: PNAMES, TEXTURE1 and TEXTURE2 are loaded by default.
*/
textures
{
	zdoom1
	{
		start = "TX_START";
		end = "TX_END";
	}
}

/*
ADDITIONAL UNIVERSAL DOOM MAP FORMAT FIELD DEFINITIONS
Only add fields here that Doom Builder does not edit with its own user-interface!
The "default" field must match the UDMF specifications!

Field data types:
0 = integer *
1 = float
2 = string
3 = bool
4 = linedef action (integer) *
5 = sector effect (integer) *
6 = texture (string)
7 = flat (string)
8 = angle in degrees (integer)
9 = angle in radians (float)
10 = XXRRGGBB color (integer)
11 = enum option (integer) *
12 = enum bits (integer) *
13 = sector tag (integer) *
14 = thing tag (integer) *
15 = linedef tag (integer) *
16 = enum option (string)
17 = angle in degrees (float)
22 = byte angle (integer)
*/
universalfields
{
	sector
	{
		friction
		{
			type = 1;
			default = 1;
		}
		
		specialeffectplanes
		{
			type = 11;
			enum = "floorceiling";
			default = 0;
		}
		
		colormapbegin
		{
			type = 0;
			default = 0;
		}
		
		colormapend
		{
			type = 0;
			default = 33;
		}
		
		foglighting
		{
			type = 3;
			default = false;
		}
		
		teambase
		{
			type = 11;
			enum = "ctfteam";
			default = 0;
		}
		
		triggersector
		{
			type = 3;
			default = false;
		}
		
		triggerobject
		{
			type = 11;
			enum = "triggerobjects";
			default = 0;
		}
		
		triggersurface
		{
			type = 11;
			enum = "triggersurfaces";
			default = 0;
		}
		
		ringdrain
		{
			type = 1;
			default = 0;
		}
	}
	
	linedef
	{
		executordelay
		{
			type = 0;
			default = 0;
		}
		midtexrepetitions
		{
			type = 0;
			default = 0;
		}
		arg5
		{
			type = 0;
			default = 0;
		}
		arg1str
		{
			type = 2;
			default = "";
		}
	}
	
	thing
	{
	}
}

/*
MAP LUMP NAMES
Map lumps are loaded with the map as long as they are right after each other. When the editor
meets a lump which is not defined in this list it will ignore the map if not satisfied.
The order of items defines the order in which lumps will be written to WAD file on save.
To indicate the map header lump, use ~MAP

Legenda:
required = Lump is required to exist.
blindcopy = Lump will be copied along with the map blindly. (useful for lumps Doom Builder doesn't use)
nodebuild = The nodebuilder generates this lump.
allowempty = The nodebuilder is allowed to leave this lump empty.
scriptbuild = This lump is a text-based script, which should be compiled using current script compiler;
script = This lump is a text-based script. Specify the filename of the script configuration to use.
*/

doommaplumpnames
{
	~MAP
	{
		required = true;
		blindcopy = true;
		nodebuild = false;
	}

	THINGS
	{
		required = true;
		nodebuild = true;
		allowempty = true;
	}

	LINEDEFS
	{
		required = true;
		nodebuild = true;
		allowempty = false;
	}

	SIDEDEFS
	{
		required = true;
		nodebuild = true;
		allowempty = false;
	}

	VERTEXES
	{
		required = true;
		nodebuild = true;
		allowempty = false;
	}

	SEGS
	{
		required = false;
		nodebuild = true;
		allowempty = false;
	}

	SSECTORS
	{
		required = false;
		nodebuild = true;
		allowempty = false;
	}

	NODES
	{
		required = false;
		nodebuild = true;
		allowempty = false;
	}

	SECTORS
	{
		required = true;
		nodebuild = true;
		allowempty = false;
	}

	REJECT
	{
		required = false;
		nodebuild = true;
		allowempty = false;
	}

	BLOCKMAP
	{
		required = false;
		nodebuild = true;
		allowempty = true;
	}
}

udmfmaplumpnames
{
	BEHAVIOR
	{
		required = false;
		nodebuild = false;
		blindcopy = true;
	}
	
	DIALOGUE
	{
		required = false;
		nodebuild = false;
		script = "ZDoom_USDF.cfg";
	}
	
	ZNODES
	{
		required = false;
		nodebuild = true;
		allowempty = false;
	}
	
	BLOCKMAP
	{
		required = false;
		nodebuild = true;
		allowempty = true;
	}
	
	REJECT
	{
		required = false;
		nodebuild = true;
		allowempty = true;
	}
	
	SCRIPTS
	{
		required = false;
		nodebuild = false;
		scriptbuild = true;
	}
}

//Default things filters
thingsfilters
{

	filter0
	{
		name = "Player starts";
		category = "starts";
		type = -1;
	}


	filter1
	{
		name = "Enemies";
		category = "enemies";
		type = -1;

	}


	filter2
	{
		name = "NiGHTS Track";
		category = "nightstrk";
		type = -1;

	}


	filter3
	{
		name = "Normal Gravity";
		category = "";
		type = -1;

		fields
		{
			2 = false;
		}

	}


	filter4
	{
		name = "Reverse Gravity";
		category = "";
		type = -1;

		fields
		{
			2 = true;
		}

	}
}

thingsfilters_udmf
{
}

// Special linedefs
speciallinedefs
{
	soundlinedefflag = 64;	// See linedefflags
	singlesidedflag = 1;	// See linedefflags
	doublesidedflag = 4;	// See linedefflags
	impassableflag = 1;
	upperunpeggedflag = 8;
	lowerunpeggedflag = 16;
	repeatmidtextureflag = 1024;
	pegmidtextureflag = 256;
}

speciallinedefs_udmf
{
	soundlinedefflag = "noclimb";
	singlesidedflag = "blocking";
	doublesidedflag = "twosided";
	impassableflag = "blocking";
	upperunpeggedflag = "dontpegtop";
	lowerunpeggedflag = "dontpegbottom";
	repeatmidtextureflag = "wrapmidtex";
	pegmidtextureflag = "midpeg";
}

scriptlumpnames
{
	MAINCFG
	{
		script = "SOC.cfg";
	}

	OBJCTCFG
	{
		script = "SOC.cfg";
	}

	SOC_
	{
		script = "SOC.cfg";
		isprefix = true;
	}

	LUA_
	{
		script = "Lua.cfg";
		isprefix = true;
	}
}

// Texture sources
textures
{
	zdoom1
	{
		start = "TX_START";
		end = "TX_END";
	}
}

// Patch sources
patches
{
	standard1
	{
		start = "P_START";
		end = "P_END";
	}

	standard2
	{
		start = "PP_START";
		end = "PP_END";
	}
}

// Sprite sources
sprites
{
	standard1
	{
		start = "S_START";
		end = "S_END";
	}

	standard2
	{
		start = "SS_START";
		end = "SS_END";
	}
}

// Flat sources
flats
{
	standard1
	{
		start = "F_START";
		end = "F_END";
	}

	standard2
	{
		start = "FF_START";
		end = "FF_END";
	}

	standard3
	{
		start = "FF_START";
		end = "F_END";
	}

	standard4
	{
		start = "F_START";
		end = "FF_END";
	}
}